1.2 

num1 = int(input("Введите первое целое число: "))
num2 = int(input("Введите второе целое число: "))
num3 = int(input("Введите третье целое число: "))
num4 = int(input("Введите четвертое целое число: "))

# Ищем максимальное число
max_num = num1
if num2 > max_num:
    max_num = num2
if num3 > max_num:
    max_num = num3
if num4 > max_num:
    max_num = num4

# Ищем минимальное число
min_num = num1
if num2 < min_num:
    min_num = num2
if num3 < min_num:
    min_num = num3
if num4 < min_num:
    min_num = num4

# Ищем третье по величине число
third_largest = None
for num in (num1, num2, num3, num4):
    if num != max_num and num != min_num:
        if third_largest is None or num > third_largest:
            third_largest = num

# Выводим результат
if third_largest is not None:
    print(f"Третье по величине число: {third_largest}")
else:
    print("Третье по величине число не существует, так как все числа равны.")















2.4

# Создаем матрицу Q(3,7)        3 строки, 7 столбцов
матрица = [
    [1, 3, 5, 7, 9, 11, 13],
    [2, 4, 6, 8, 10, 12, 14],
    [3, 5, 7, 9, 11, 13, 15]
]

#  исходная матрица
print("Исходная матрица:")
for столбец in матрица:      # пробегаем по столбца матрицы, чтобы вывести их
    print(столбец)

# Заменяем первые три столбца на значение 2
for столбец in матрица:      # пробегаем по столбца матрицы, чтобы заменить первые 3 на значение "2"
    for i in range(3):
        столбец[i] = 2       # замена в трех столбца чисел на значение "2"

# Выводим измененную матрицу
print("\nМатрица после замены:")
for столбец in матрица:
    print(столбец)















2.5

# # Создаем матрицу N(6,6)
# матрица_6х6 = [
#     [1, 2, 3, 4, 5, 6],
#     [7, 8, 9, 10, 11, 12],
#     [13, 14, 15, 16, 17, 18],
#     [19, 20, 21, 22, 23, 24],
#     [25, 26, 27, 28, 29, 30],
#     [31, 32, 33, 34, 35, 36]
# ]
#
# # Задаем условия
# K = 2
#
# # Формируем одномерный массив Y
# новый_массив = []
#
# # for i in range(len(матрица_6х6)):
# #     for j in range(i + 1, len(матрица_6х6[i])):
# #         if матрица_6х6[i][j] <= K and матрица_6х6[i][j] > (i + j):
# #             новый_массив.append(матрица_6х6[i][j])
#
# for i in range(len(матрица_6х6)):
#     for j in range(len(матрица_6х6[i])):
#         print(f"Проверка для i={i}, j={j}: матрица_6х6[{i}][{j}] = {матрица_6х6[i][j]}")
#         if матрица_6х6[i][j] <= K and матрица_6х6[i][j] > (i + j):
#             новый_массив.append(матрица_6х6[i][j])
#
#
#
# # Выводим матрицу N
# print("\nМатрица N(6,6):")
# for строка in матрица_6х6:
#     print(строка)
#
# # Выводим одномерный массив Y
# print("\nОдномерный массив Y:")
# print(новый_массив)
#


# Создаем матрицу N(6,6)
матрица_6х6 = [
    [1, 2, 3, 4, 5, 6],
    [7, 8, 9, 10, 11, 12],
    [13, 14, 15, 16, 17, 18],
    [19, 20, 21, 22, 23, 24],
    [25, 26, 27, 28, 29, 30],
    [31, 32, 33, 34, 35, 36]
]

# Задаем условия
K = 2

# Формируем одномерный массив Y
новый_массив = []

for i in range(len(матрица_6х6)):
    for j in range(len(матрица_6х6[i])):
        print(f"Проверка для i={i}, j={j}: матрица_6х6[{i}][{j}] = {матрица_6х6[i][j]}")
        if j >= i and матрица_6х6[i][j] <= K and матрица_6х6[i][j] > (i + j):
            новый_массив.append(матрица_6х6[i][j])

# Выводим матрицу N
print("Матрица N(6,6):")
for строка in матрица_6х6:
    print(строка)

# Выводим одномерный массив Y
print("\nОдномерный массив Y:")
print(новый_массив)












3

import random
import timeit

def сортировка_методом_пузырька(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

def прямое_включение(arr):          # (вставками!!)
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def прямой_выбор(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

def шейкерная_сортировка(arr):
    n = len(arr)
    swapped = True
    start = 0
    end = n - 1
    while swapped:
        swapped = False
        for i in range(start, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        if not swapped:
            break
        swapped = False
        end = end - 1
        for i in range(end - 1, start - 1, -1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        start = start + 1

def методом_шелла(arr):
    n = len(arr)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2

def метод_хоара(arr):
    if len(arr) <= 1:
        return arr
    опорный_элемент = arr[len(arr) // 2]
    left = [x for x in arr if x < опорный_элемент]
    right = [x for x in arr if x > опорный_элемент]
    return метод_хоара(left) + [опорный_элемент] + метод_хоара(right)

def генерация_массива(size):
    return [random.randint(0, 100) for _ in range(size)]  # генерация случайных чисел от 0 до 100

def время_выполнения(func, arr):
    return timeit.timeit(lambda: func(arr.copy()), number=1)

if __name__ == "__main__":
    размер_массива = 10000  # Размер массива
    кол_во_повторений = 1  # Количество повторений для каждой сортировки

    # Генерация случайного массива
    генерация_массива = генерация_массива(размер_массива)

    # Измерение времени выполнения для каждой сортировки
    все_сортировки = [сортировка_методом_пузырька, прямое_включение, прямой_выбор, шейкерная_сортировка, методом_шелла, метод_хоара]

    for сортировка in все_сортировки:
        время_выполнения_среднее = sum(время_выполнения(сортировка, генерация_массива) for _ in range(кол_во_повторений)) / кол_во_повторений
        print(f"{сортировка.__name__}: {время_выполнения_среднее} сек")


# Общий порядок временной сложности различных алгоритмов сортировки:
#
# Сортировка методом Хоара (быстрая сортировка) - O(n log n) в среднем случае
# Сортировка методом Шелла - O(n log^2 n)
# Прямое включение - O(n^2)
# Прямой выбор - O(n^2)
# Шейкерная сортировка - O(n^2)
# Сортировка методом пузырька - O(n^2)




# Быстрая сортировка (Сортировка Хоара):
# В среднем случае: O(n log n)
# В худшем случае: O(n^2)


# Сортировка методом Шелла:
# В среднем случае: О(n log^2 n) (но это сложно точно оценить, так как зависит от конкретной последовательности промежутков)


# Прямое включение (вставками!!):
# В среднем случае: O(n^2)
# В худшем случае: O(n^2)


# Прямой выбор (Selection Sort):
# В среднем случае: O(n^2)
# В худшем случае: O(n^2)


# Шейкерная сортировка (Cocktail Shaker Sort):
# В среднем случае: O(n^2)
# В худшем случае: O(n^2)


# Сортировка методом пузырька (Bubble Sort):
# В среднем случае: O(n^2)
# В худшем случае: O(n^2)













4.2

def поиск_подстроки(строка_поиска, подстрока_для_поиска):
    длина_строки_поиска = len(строка_поиска)
    длина_подстроки = len(подстрока_для_поиска)

    i = 0
    while i + длина_подстроки <= длина_строки_поиска:         # цикл, который продолжается до тех пор, пока значение i + "строка_поиска" не выходит за границы строки. Это нужно, чтобы осталось достаточное кол-во символов в строке, чтобы сравнивать с подстрокой
        совпадение = True                                     # используется для отслеживания совпадения подстроки с текущим фрагментом строки.
        for j in range(длина_подстроки):                      # цикл, который бежит по символам подстроки
            if строка_поиска[i + j] != подстрока_для_поиска[j]:
                совпадение = False                            # если хотя бы одна пара символов не совпадает, устанавливаем флаг "совпадение" в False и прерываем вложенный цикл.
                break

        if совпадение:                            # если флаг "совпадение" остается True после завершения вложенного цикла, значит, все символы подстроки совпали с соответствующими символами строки.
            return i, i + длина_подстроки - 1  # Возвращаем диапазон индексов подстроки в строке

        i += 1                      # если совпадения не найдено, то увеличиваем i и продолжаем поиск.

    return -1, -1                    # Вхождение не найдено

# Пример использования
строка_для_поиска = "на дворе трава, на траве дрова"
подстрока_поиска = "траве"
начало, конец = поиск_подстроки(строка_для_поиска, подстрока_поиска)

if начало != -1:
    print(f"Вхождение подстроки найдено с {начало} по {конец}")
else:
    print("Вхождение подстроки не найдено")















5

очередь = []  # Создаем пустой массив для хранения элементов очереди

# Функция для добавления элемента в очередь
def добавление_элемента_в_очередь(item):
    очередь.append(item)

# Функция для извлечения элемента из очереди
def удаление_элемента_из_очереди():
    if очередь:  # Проверяем, не пуста ли очередь
        элемент = очередь.pop(0)  # Извлекаем элемент из начала очереди
        print("извлеченный элемент из очереди:", элемент)
        return элемент
    else:
        print("очередь пустая")
        return None

# Пример использования очереди на базе массива
добавление_элемента_в_очередь(1)
добавление_элемента_в_очередь(2)
добавление_элемента_в_очередь(3)
добавление_элемента_в_очередь(4)

удаление_элемента_из_очереди()
удаление_элемента_из_очереди()
удаление_элемента_из_очереди()
удаление_элемента_из_очереди()
удаление_элемента_из_очереди()  # Попытка извлечь элемент из пустой очереди

# Проверяем пустоту очереди
is_empty = len(очередь) == 0
print("Очередь пуста:", is_empty)

